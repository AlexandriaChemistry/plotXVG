#!/usr/bin/env python3

import math, os, argparse, string
import tkinter, matplotlib
import matplotlib.pyplot as plt
import numpy as np
matplotlib.use('TkAgg')
from matplotlib import rcParams
from matplotlib.animation import FuncAnimation
from xvgutils import *

viewDebug = False

# Hardcoded formatting, Yay!
defcolors  = ["#1f77b4", "#ff7f0e", "#2ca02c", "#7f0000", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf", "#aec7e8","#ffbb78", "#98df8a", "#ff9896", "#c5b0d5", "#c49c94", "#f7b6d2", "#c7c7c7", "#dbdb8d", "#9edae5"]
defmarkers = ["o", "+", "v", "x", "^", "<", ">", "s", "p", "*", ".", "D", "d", "h", "H", "|", "_"]
deflines   = [ 'solid', 'dashed', 'dashdot', 'dotted' ]

def parseArguments():
    parser = argparse.ArgumentParser(
      prog='plotxvg',
      description=
"""
Simple script to quickly plot xy files produced by e.g. ACT or GROMACS.
There is limited support for Grace features such superscripts and subscripts
in labels. Remember to add an argument for each file you want to plot. 
If datasets with different x- or y-labels are loaded together the x- and y-labels of the latter dataset will be used.
One nice feature is that you can get live updates of plots that
are generated by a running program, using the -follow option.
""",
      epilog= 'Example: plotxvg -f filename1 filename2 -ls solid dashed -save path/to/saved_plot.pdf')
    parser.add_argument("-f",   "--filename", nargs="*", help="Filename(s) to read and plot", type=str, default=None)
    parser.add_argument("-follow", "--follow", help="Continuously update the plot by re-reading the input file(s)", action="store_true")
    parser.add_argument("-debug", "--debug", help="Turn on printing of debugging messages", action="store_true")
    fontname="Arial"
    parser.add_argument("-font", "--fontname", help="Font for all text.", type=str, default=fontname)
    axislabelfontsize=26
    parser.add_argument("-alfs", "--axislabelfontsize", help="Axis label font size, default "+str(axislabelfontsize), type=int, default=axislabelfontsize)
    titlefontsize=30
    parser.add_argument("-tfs", "--titlefontsize", help="Title font size, set to zero for no title, default "+str(titlefontsize), type=int, default=titlefontsize)
    legendfontsize=26
    parser.add_argument("-lfs", "--legendfontsize", help="Legend font size, set to zero for no legend, default "+str(legendfontsize), type=int, default=legendfontsize)
    tickfontsize=24
    parser.add_argument("-tickfs", "--tickfontsize", help="Tick font size, default "+str(tickfontsize), type=int, default=tickfontsize)
    parser.add_argument("-ls", "--linestyle", help="What kind of line style: solid, dashed, dashdot, dotted", nargs="+", type=str, default=None)
    parser.add_argument("-mk", "--marker", help="Use markers for data sets: o, +, x, <, >...", nargs="+", type=str, default=None)
    defmksize = 10
    parser.add_argument("-mksize", "--markersize", help="Size of filled markers for data sets, default "+str(defmksize), default=defmksize, type=int)
    defmkedgew = 2
    parser.add_argument("-mkwidth", "--markeredgewidth", help="Size of character markers (e.g. +) for data sets, default "+str(defmkedgew), default=defmkedgew, type=float)
    parser.add_argument("-colors", "--colors", help="Colors for the plots. Colors defined by the user will be applied to the datasets in order. If there are more datasets than color inputs, default colors will be used.", nargs="*", type=str, default=None)
    parser.add_argument("-save", "--save", help="Save plot. Please specify saving location and preferred filetype (.pdf, .png...)", type=str, default=None)
    parser.add_argument("-sqfig", "--squarefig", help="Make the figure square", action="store_true")
    parser.add_argument("-eqax", "--equalaxes", help="Make the plot square with equally large axes", action="store_true")
    parser.add_argument("-bar", "--bar", help="Make a bar graph", action="store_true")
    parser.add_argument("-noshow", "--noshow", help="Do not show the figure", action="store_true")
    parser.add_argument("-res", "--residual", help="Subtract x from y for all data sets - useful for correlation plots", action="store_true")
    parser.add_argument("-fl", "--filelabel", help="Add the filename to the labels in the plot (may yield long labels)", action="store_true")
    parser.add_argument("-logy", "--logy", help="Use a log scale on the Y-axis", action="store_true")
    parser.add_argument("-xmin", "--xmin", help="Minimum value of X-axis. Default = defined by data.", type=float, default=0.0)
    parser.add_argument("-xmax", "--xmax", help="Maximum value of X-axis. Default = defined by data.", type=float, default=0.0)
    parser.add_argument("-ymin", "--ymin", help="Minimum value of Y-axis. Default = defined by data.", type=float, default=0.0)
    parser.add_argument("-ymax", "--ymax", help="Maximum value of Y-axis. Default = defined by data.", type=float, default=0.0)
    xframe = 16
    parser.add_argument("-xframe", "--xframe", help="Width of the plot 100 pixels, default "+str(xframe), type=int, default=xframe)
    yframe = 9
    parser.add_argument("-yframe", "--yframe", help="Height of the plot 100 pixels, default "+str(yframe), type=int, default=yframe)
    parser.add_argument("-panels", "--panels", help="Generate different panels to plot in, one file per panel", action="store_true")
    subfigx = -0.15
    subfigy = 1.0
    parser.add_argument("-sfx", "--subfigureX", help="X position of subfigure label when using panels. Default "+str(subfigx), type=float, default=subfigx)
    parser.add_argument("-sfy", "--subfigureY", help="Y position of subfigure label when using panels. Default "+str(subfigy), type=float, default=subfigy)
    parser.add_argument('-ign', '--ignore', help="legends of the series to ignore. Please specify the whole legend label.", nargs='*', default=[])
    parser.add_argument("-title", "--title", help="User-defined title(s)", nargs="+", type=str, default=None)
    parser.add_argument("-dslegends", "--datasetlegends", help="Set user-defined legends. If legends are already defined in the input file they are combined for each dataset i.e. '<user-defined legend> <pre-defined legend>'.", nargs="*", type=str, default=None)
    parser.add_argument("-sharelabel", "--sharelabel", help="Show only the x-labels on the last row of plots and the y-labels on the first column of plots (useful if all subplots share the same x- and y-labels)", action="store_true")
    leg_x = 0.02
    parser.add_argument("-legend_x", "--legend_x", help="Put the legend box horizontally on this position, default "+str(leg_x), type=float, default=leg_x)
    leg_y = 0.98
    parser.add_argument("-legend_y", "--legend_y", help="Put the legend box vertically on this position, default "+str(leg_y), type=float, default=leg_y)
    parser.add_argument("-stats", "--stats", help="Print RMSD and R2 values of datasets (x-axis is reference data and y-axis holds the predicted values)", action="store_true")
    return parser.parse_args()

def texify(txt:str)->str:
    return txt.replace("\\S", "$^{").replace("\\s", "$_{").replace("\\N", "}$")
    
class DataSet:
    def __init__(self):
        # legends for datasets
        self.legend   = []
        # labels for axes (and titles)
        self.labels = {}
        self.dataset = []

    def calc_rmsd_r2(self, x, y):
        x = np.asarray(x)
        y = np.asarray(y)
        rmsd = np.sqrt(np.mean((x - y) ** 2))
        
        ss_res = np.sum((x - y) ** 2)
        ss_tot = np.sum((x - np.mean(x)) ** 2)
        r2 = 1 - ss_res / ss_tot if ss_tot != 0 else np.nan
        return rmsd, r2

    def read(self, filenm:str, residual:bool, filelabel:bool, arglegend:str, setcount):
        try:
            legend, label, dataset = read_xvg(filenm, residual, filelabel)
        except Exception as e:
            print("Error when reading input files:\n", e)
        if len(dataset) == 0:
            if viewDebug:
                print("File %s has no data" % filenm)
        else:
            if viewDebug:
                print("Read %d labels and %d legends from %d dataset(s) in input file %d" % (len(label), len(legend), len(dataset), setcount+1))
            for d in dataset:
                self.dataset.append(d)
            for k in label:
                self.labels[k] = label[k]
            # This has to be a list, there can be multiple data sets per file
            #Add labels to axes if there is none in the dataset
            if "xlabel" not in self.labels:
                self.labels["xlabel"] = "(arbitrary units)"
            if "ylabel" not in self.labels:
                self.labels["ylabel"] = "(arbitrary units)"            
            if len(legend) > 0:
                for l in range(len(legend)):
                    if arglegend:
                        self.legend.append(texify(arglegend + " " + legend[l]))
                    else:
                        self.legend.append(texify(legend[l]))
            elif arglegend:
                self.legend.append(texify(arglegend))
            if args.stats:
                #Fetch the dataset without residual
                _,_,ori_dataset = read_xvg(filenm, False, filelabel)
                #Print R2 and RMSD values in legend
                for d in range(len(ori_dataset)):
                    ds = ori_dataset
                    rmsd, r2 = self.calc_rmsd_r2(ds[d].x, ds[d].y)
                    self.legend[d] = f"{self.legend[d]}, RMSD = {rmsd:.4f}, R2 = {r2:.4f}"

    def set_extent(self, myax, args):
        if len(self.dataset) < 1:
            print("Insufficient data points to set extents.")
            return 0, 0, 0, 0
        xxmin = self.dataset[0].xmin
        xxmax = self.dataset[0].xmax
        yymin = self.dataset[0].ymin
        yymax = self.dataset[0].ymax
        for data in self.dataset[1:]:
            xxmin = min(xxmin, data.xmin)
            xxmax = max(xxmax, data.xmax)
            yymin = min(yymin, data.ymin)
            yymax = max(yymax, data.ymax)
        if args.equalaxes:
            mmin = min(xxmin, yymin)
            mmax = max(xxmax, yymax)
            delta = 5+(mmax-mmin)/20
            mmin -= delta
            mmax += delta
            xxmin = mmin
            xxmax = mmax
            yymin = mmin
            yymax = mmax
        if args.xmin:
            xxmin = args.xmin
        if args.xmax:
            xxmax = args.xmax
        if args.ymin:
            yymin = args.ymin
        if args.ymax:
            yymax = args.ymax
        # Now effectuate the options
        if xxmin == xxmax or yymin == yymax:
            if viewDebug:
                print("Warning: min and max for x or y are equal, expanding range.")
            xxmin -= xxmin*0.5
            xxmax += xxmax*0.5
            yymin -= yymax*0.5
            yymax += yymax*0.5
        if args.equalaxes:
            if xxmin == yymin and xxmax == yymax:
                myax.set_aspect('equal', adjustable='box')
            elif viewDebug:
                print("Option -eqax overruled by min and max options")
        return xxmin, xxmax, yymin, yymax

    def decorate(self, thisax, args, title, sharelabel_x, sharelabel_y):
        # Now add the fancy stuff
        if args.titlefontsize > 0:
            if args.title and title != "None":
                thisax.set_title(texify(title), fontsize=args.titlefontsize/ncolumn)
            elif "title" in self.labels and "subtitle" in self.labels:
                title_text = texify(self.labels["title"])
                subtitle_text = texify(self.labels["subtitle"])
                thisax.set_title(f"{title_text}\n{subtitle_text}", fontsize=args.titlefontsize/ncolumn, pad=args.titlefontsize/ncolumn*0.5)
            elif "title" in self.labels and "subtitle" not in self.labels:
                thisax.set_title(texify(self.labels["title"]), fontsize=args.titlefontsize/ncolumn, pad=args.titlefontsize/ncolumn*0.5)
            elif "title" not in self.labels and "subtitle" in self.labels:
                thisax.set_title(texify(self.labels["subtitle"]), fontsize=args.titlefontsize/ncolumn, pad=args.titlefontsize/ncolumn*0.5)

        if "xlabel" in self.labels and args.panels and sharelabel_x == True: #Print x label for the last row
            pass
        else:
            thisax.set_xlabel(texify(self.labels["xlabel"]), fontsize=args.axislabelfontsize/ncolumn, labelpad=args.axislabelfontsize/ncolumn*0.5)

        if "ylabel" in self.labels and args.panels and sharelabel_y == True: #Print y label for the first column
            pass
        else:
            thisax.set_ylabel(texify(self.labels["ylabel"]), fontsize=args.axislabelfontsize/ncolumn, labelpad=args.axislabelfontsize/ncolumn*0.5)
        # Legend box placement
        if args.legendfontsize > 0 and len(self.legend) > 0:
            thisax.legend(loc='upper left', bbox_to_anchor=(args.legend_x, args.legend_y), fontsize=args.legendfontsize/ncolumn)

    def do_bars(self, thisax, argcolors, idx, total_datasets, setcount, group_width):
        print_legend = False
        if args.datasetlegends:
            print_legend = True
        else:
            print_legend = len(self.legend) == len(self.dataset)
        if viewDebug:
            print("%d legends read in file nr %d" % ( len(self.legend), setcount+1 ) )
        for n in range(len(self.dataset)):
            xy = self.dataset[n]

            x = np.asarray(xy.x)
            #Compute a suitable spacing based on mean difference between x values
            if len(x) > 1:
                # sort justin case
                xs_sorted = np.sort(x)
                spacing = np.mean(np.diff(xs_sorted)) #mean difference between each consecutive value
                if spacing == 0:
                    spacing = 1.0
            else:
                spacing = 1.0

            # total width for the whole group of bars (all datasets) at each x
            total_group_width = spacing * group_width
            # width of a single bar (split group among total_bars)
            bar_width = total_group_width / total_datasets

            current_index = idx + n
            # compute an offset for the local dataset (placement of bar for each x value)
            offset = (current_index - (total_datasets - 1) / 2.0) * bar_width
            # Place each bar relative to center x
            xpos = x + offset

            #Colors and legends
            mylegend  = None
            if len(self.legend) > n and self.legend[n] not in args.ignore:
                if print_legend:
                    mylegend = self.legend[n]
            mycolor=argcolors[n]
            if viewDebug:
                print(f"\t mylegend  {n+1} = {mylegend}")
                print(f"\t mycolor  {n+1} = {mycolor}\n")

            thisax.bar(xpos, xy.y, width=bar_width, bottom=0.0, align="center", label=mylegend, color=mycolor)

    def do_lines(self, thisax, argcolors, arglines, argmarkers, setcount):
        print_legend = False
        if args.datasetlegends:
            print_legend = True
        else:
            print_legend = len(self.legend) == len(self.dataset)

        if viewDebug:
            print("%d legends read in file nr %d" % ( len(self.legend), setcount+1) )
        for n in range(len(self.dataset)):
            mylegend  = None
            if len(self.legend) > n and self.legend[n] not in args.ignore:
                if print_legend:
                    mylegend = self.legend[n]
            if args.linestyle:
                myline = arglines[n]
            else:
                myline = "None" #plot function only accepts None as a string
            mymarker = "None"
            if args.marker or (args.marker is None and args.linestyle is None):
                mymarker = argmarkers[n]
            mycolor = argcolors[n]
            if viewDebug:
                print(f"\t mylegend  {n+1} = {mylegend}")
                print(f"\t mymarker {n+1} = {mymarker}")
                print(f"\t myline   {n+1} = {myline}")
                print(f"\t mycolor  {n+1} = {mycolor}\n")
            if hasattr(self.dataset[n], "dy") and self.dataset[n].dy is not None:
                thisax.errorbar(self.dataset[n].x, self.dataset[n].y, yerr=self.dataset[n].dy,
                                capsize=3, label=mylegend, markersize=args.markersize/ncolumn, linewidth=2/ncolumn,
                                ls=myline, marker=mymarker, color=mycolor, ecolor=mycolor)
            else:
                thisax.plot(self.dataset[n].x, self.dataset[n].y, markersize=args.markersize/ncolumn, linewidth=4/ncolumn,
                            label=mylegend, ls=myline, marker=mymarker, color=mycolor, markeredgewidth=args.markeredgewidth/ncolumn)
            


def plot_once(axs, args):
    numaxs = axs.size if hasattr(axs, 'size') else 1

    arglegend = []
    if args.datasetlegends:
        arglegend = []
        for value in args.datasetlegends:
            if value != "None": #If user only wants to add a legend to one of the datasets in a file, set None
                arglegend.append(value)
            else:
                arglegend.append("")
        if viewDebug:
            print("Found the following command-line legends {}".format(arglegend), "\n")
    datasets = []

    # Create new dataset for each file BEFORE plotting
    total_datasets = 0
    xmins = []
    xmaxs = []
    ymins = []
    ymaxs = []
    for filenumber in range(nfiles):
        datasets.append(DataSet())
        if len(arglegend) >= filenumber+1:
            mylegend = arglegend[filenumber]
        else:
            mylegend = None
        datasets[-1].read(args.filename[filenumber], args.residual,
                          args.filelabel, mylegend, filenumber)
        total_datasets += len(datasets[-1].dataset)
        
        # Shortcut for the current axis
        thisax = axs.flat[filenumber % numaxs]
        #Fetch mininmum and maximum values
        xxmin, xxmax, yymin, yymax = datasets[filenumber].set_extent(thisax, args)
        xmins.append(xxmin)
        xmaxs.append(xxmax)
        ymins.append(yymin)
        ymaxs.append(yymax)
    #Save the global x/y minima and maxima respectively
    xxmin = min(xmins)
    xxmax = max(xmaxs)
    yymin = min(ymins)
    yymax = max(ymaxs)

    if viewDebug:
        print("Total datasets found: ", total_datasets, "\n")

    #Define colors markers and linstyles before going in to loop
    colors = args.colors if args.colors else []
    if args.marker:
        marker = args.marker
    elif args.marker is None and args.linestyle is None: #If neither markers nor linestyle is defined, add markers
        marker = []
    else:
        marker = None
    linestyle = args.linestyle if args.linestyle else None
    # Build a color list long enough for all datasets (maximum is the length of defcolors)     
    if len(colors) < total_datasets:
        if viewDebug:
            print("More datasets than color inputs. Adding colors.\n")
        # Repeat appending from defcolors
        c = 0
        while len(colors) < total_datasets:
            colors.append(defcolors[c % len(defcolors)])
            c += 1

    idx = 0
    # Plot one dataset at a time
    if args.bar and viewDebug:
        print("Doing bar graphs\n")
    for filenumber in range(nfiles):
        # Shortcut for the current axis
        thisax = axs.flat[filenumber % numaxs]

        #number of datasets within a file
        nrdatasets = len(datasets[filenumber].dataset)
        # Assign colors depending on nr of datasets within each file
        if args.panels:
            these_colors = colors[0:nrdatasets] #Each panel should have the same colors, thus start from index zero in the color list
        else:
            these_colors = colors[idx:idx+nrdatasets] #Multiple datasets plotted together must recieve a new color in the list

        if args.marker:
            if len(args.marker) < nrdatasets: #markers will be applied for each dataset in each file
                c = 0
                while len(marker) < nrdatasets:
                    marker.append(defmarkers[c % len(defmarkers)])
                    c += 1
            elif len(args.marker) >= total_datasets: #markers will be applied to each dataset in total
                marker = args.marker[idx:idx+nrdatasets]
        elif args.marker is None and args.linestyle is None:
            c = 0
            while len(marker) < nrdatasets:
                marker.append(defmarkers[c % len(defmarkers)])
                c += 1
        else:
            marker = None

        if args.linestyle:
            if len(args.linestyle) < nrdatasets:
                c = 0
                while len(linestyle) < nrdatasets:
                    linestyle.append(deflines[c % len(deflines)])
                    c += 1
            elif len(args.linestyle) >= total_datasets:
                linestyle = args.linestyle[idx:idx+nrdatasets]
        else: 
            linestyle = None

        if args.logy:
            thisax.set_yscale('log')

        if args.bar:
            # Pass color list for the datasets in this file so bars can be colored
            datasets[filenumber].do_bars(
                thisax,
                these_colors,
                idx, 
                total_datasets, 
                filenumber,
                group_width=0.9,   
            )
        else:
            datasets[filenumber].do_lines(
                thisax,
                these_colors,
                linestyle,
                marker,
                filenumber
            )
        idx += nrdatasets

        if args.panels and numaxs > 1:
            sublabel = string.ascii_uppercase[filenumber] #Add letter to each subplot
            if viewDebug:
                print(f"Setting subplot {filenumber+1} to {sublabel}\n")
            thisax.text(args.subfigureX, args.subfigureY, sublabel,
                    transform=thisax.transAxes, 
                    size=args.axislabelfontsize/ncolumn, weight='bold', color='black')
        # Tick font labels
        for aa in ['x', 'y']:
            thisax.tick_params(axis=aa, labelsize=args.tickfontsize/ncolumn)
            
        # If x- or ylabels are not the same they should not be scaled together, fetching local minimas and maximas. 
        if args.panels and args.equalaxes == False: #If equalaxes, use global minimas ans maximas
            if datasets[0].labels.get("xlabel") != datasets[-1].labels.get("xlabel"):
                xxmin = xmins[filenumber]
                xxmax = xmaxs[filenumber]
            if datasets[0].labels.get("ylabel") != datasets[-1].labels.get("ylabel"):
                yymin = ymins[filenumber]
                yymax = ymaxs[filenumber]

        # Scale the plot such that the content is visible
        deltax = (xxmax-xxmin)*0.05
        thisax.set_xlim(xxmin-deltax, xxmax+deltax)
        deltay = (yymax-yymin)*0.05
        thisax.set_ylim(yymin-deltay, yymax+deltay)

        # Set labels and titles
        title = args.title[filenumber] if args.title else None
        if args.sharelabel and args.panels:
            rowindex = filenumber // ncolumn #counts rows by taking the division without rest
            columnindex = filenumber % ncolumn #counts columns by taking the rest
            # Define what x- and y-labels to print
            if rowindex == nrow-1 and columnindex == 0: #Last row and forst column (only applies to lower left plot)
                datasets[filenumber].decorate(thisax, args, title, sharelabel_x=False, sharelabel_y=False)
            elif rowindex == nrow-1: #Last row
                datasets[filenumber].decorate(thisax, args, title, sharelabel_x=False, sharelabel_y=True)
            elif columnindex == 0: #First column
                datasets[filenumber].decorate(thisax, args, title, sharelabel_x=True, sharelabel_y=False)
            else:
                datasets[filenumber].decorate(thisax, args, title, sharelabel_x=True, sharelabel_y=True)
        elif args.sharelabel and not args.panels:
            print("Cannot use the sharelabel flag without the panels flag. Will ignore sharelabel.")
            datasets[filenumber].decorate(thisax, args, title, sharelabel_x=False, sharelabel_y=False)          
        else:
            datasets[filenumber].decorate(thisax, args, title, sharelabel_x=False, sharelabel_y=False)

    # Finally, printing time
    if args.save:
        if viewDebug:
            print(f"Saving to: {args.save}")
        # Print just once!
        fig.savefig(args.save, bbox_inches='tight')
        args.save = None

def animate(t):
    plot_once()
    plt.gcf().autofmt_xdate()
    plt.tight_layout()

if __name__ == '__main__':   
    args = parseArguments()
    if args.debug:
        viewDebug = True

    # Define the number of columns and files
    nfiles  = len(args.filename)
    ncolumn = 1

    if args.panels:
        ncolumn = int(math.sqrt(nfiles))
        nrow = int(nfiles/ncolumn)
        if nfiles % ncolumn != 0:
            nrow += 1
        if args.squarefig:
            xframe = (args.yframe)
            yframe = (args.yframe/ncolumn)*nrow
        else:
            xframe = args.xframe
            yframe = args.yframe
        fig, axs = plt.subplots(nrow, ncolumn, figsize=(xframe, yframe), constrained_layout=True) #constrained_layout=True usually more recommended than plt.tight_layout()
    else:
        if args.squarefig:
            xframe = args.squarefig
            yframe = xframe
        else:
            xframe = args.xframe
            yframe = args.yframe
        fig, axs = plt.subplots(figsize=(xframe, yframe), constrained_layout=True)
        axs = np.array([axs])

    rcParams['font.family'] = 'sans-serif'
    rcParams['font.sans-serif'] = [args.fontname]

    if args.filename:
        if args.follow:
            ani = FuncAnimation(plt.gcf(), animate, interval=5000)
        else:
            try:
                plot_once(axs, args)
            except Exception as e:
                print("Plotting failed:", e)
        if not args.noshow:
            plt.show()
